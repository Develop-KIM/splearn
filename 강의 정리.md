# 소프트웨어 개발에서 도메인
**사용자**가 **프로그램, 또는 소프트웨어 서비스를 적용하는 주제 영역을 도메인**이라 한다.

# 도메인 모델
- 소프트웨어는 도메인의 **핵심 개념과 요소들을 통합하고, 그 관계를 정확하게 구현**해야 한다.
- 도메인은 현실 세계의 일부이고, 단순히 코드로 직접 옮길수 없다 <br/>
  따라서, **도메인의 추상화인 도메인 모델**을 만들어야 한다.
- 도메인 모델은 소프트웨어가 해결하려는 특정 문제 영역(도메인)의 핵심지도
- 도메인에 존재하는 **중요한 개념과 이들 사이의 관계, 그리고 규칙**을 표현

# 도메인 주도 설계(Domain-Driven Design)
- 도메인의 **복잡성이 주는 문제를 해결**하기 위한 접근 방법
- **도메인 모델을 개발 과정의 중심**에 두는 방법이다.
- **도메인 모델이 설계와 코드까지** 이어져야 한다.
- 팀 안에서 **도메인 모델에 기반한 단일 어휘체계**를 만들고 <br/>
  이를 문서, 회의, 대화, 코드까지 일관되게 사용한다. (보편 언어)

# 도메인 모델과 보편 언어를 프로젝트에 기록
- 용어사전.md
- 도메인 모델.md
- 도메인 모델.drawio

# 도메인 모델 만들기
- 듣고 배우기
- '중요한 것'들 찾기 (개념 식별)
- '연결 고리' 찾기 (관계 정의)
- '것'들을 설명하기 (속성 및 기본 행위 명시)
- 그려보기 (시각화) <br/>
  예시) 클래스 다이어그램
- 이야기 하고 다듬기 (반복)

# 도메인 전문가가 없다면
- 기획자, PO를 가상의 도메인 전문가로 활용
- 다양한 탐색과 집단적인 학습 - 이벤트 스토밍
- 가설 기반의 점진적인 모델링
- 보편 언어의 의식적인 구축과 진화
- **경쟁 업체 서비스 분석**

# 엔티티(Entity)
- 도메인 안에 있는 대상이나 개념
- 고유한 식별자(identity)를 가지고 이를 통해서 개별적으로 구분된다.
- 생명주기(life cycle)를 가진다. 시간의 흐름에 따라 상태가 변경될 수 있다.

# 도메인 모델 패턴
- 도메인/비즈니스 로직을 구성하는 아키텍처 패턴의 한 가지
- 도메인 모델의 **속성과 행위를 모두 포함**하는 **도메인의 오브젝트 모델**이다.
- 오브젝트 모델이기 때문에 **복잡한 연관 관계, 커스텀 속성, 상속** 등을 사용할 수 있다.
- 트랜잭션 스크립트는 **하나의 업무절차(TX)를 처리하기 위한 스크립트**(메소드)를 만들고 <br/>
  비즈니스 로직을 **순서대로 코드로** 작성하는 방법

# 값 객체(Value Object)
- 도메인 모델에서 식별자가 필요하지 않고 속성/값으로만 구별되는 오브젝트
- 엔티티가 너무 많은 책임을 가지는 것을 방지하고 <br/>
  특정 속성 관련 행위를 분리해서 엔티티를 더 집중된 상태로 유지하게 한다.
- 원시 타입보다는 도메인 개념을 더 명시적으로 나타내서 모델의 명확성을 높인다.
- 생성 이후에 상태가 변하지 않고 변경이 필요하면 새로운 객체로 교체한다.
- 풍부한 기능을 가진다.
- 자체 유효성 검사도 가능하다.

# 원시 타입을 객체로 교체 - 리팩터링
- 원시 타입의 남용을 개선하고 코드 **명시성과 안정성을 높이는 리팩터팅** 방법
- 값 객체는 **도메인 모델**의 핵심 **구성 요소**로 **값 그 자체의 의미를 담아내고** <br/>
  **불변성, 동등성** 등의 도메인 로직을 포함하여 설계하는 방식

# 도메인 모델 패턴의 두 가지 스타일
- **단순 도메인 모델(Simple Domain Model)**: <br/>
  DB 설계와 유사, 테이블에 대해 하나의 도메인 오브젝트
- **풍성한 도메인 모델(Rich Domain Model)**: <br/>
  상속, 전략, GoF 디자인 패턴, 연관 관계 <br/>
  복잡한 로직에 적합하지만 DB 매핑이 어려울 수 있다.

# 도메인 로직의 API 개발
- 도메인 모델 패턴은 트랜잭션 스크립트처럼 **작업 단위의 절차형 API**를 만들기가 어렵다.
- 도메인 로직의 명확한 **작업 단위 API**를 제공하는 **애플리케이션 서비스**가 필요

# 아키텍처
- 시스템의 **기본적인 구조**를 정의한다.
- 시스템의 중요한 **품질 속성에 큰 영향**을 미친다.
- **설계 결정의 기반**이 되는 핵심적인 개념이다.
- 기본 **구성 요소**와 **상호 관계, 제약 조건, 원칙** 등을 포함한다.

# 계층형 아키텍처(Layered Architecture)
- 서브 시스템을 **계층(layers)으로 구조화** 하는 아키텍처 스타일이다.
- 계층은 **사용 관계로 연결**된다.
- 사용 관계는 일반적으로 **단방향이어야 한다**는 핵심 제약이 있다.
  - 상위 계층이 하위 계층의 서비스를 사용하는 **하향식 흐름**을 가진다.
- 각 계층이 하위 계층의 내부 작동 방식을 알지 못하고 **제한된 인터페이스만 사용**하도록 한다. <br/>
  (계층 격리 Layers of Isolation)
  - 어떤 레이어의 **변경**이 다른 레이어의 컴포넌트에게 가능한 **영향을 주지 않도록** 해야 한다.

# 헥사고날 아키텍처
- 2005년 **앨리스터 코번**이 제안한 아키텍처
- 계층형 아키텍처의 단방형 비대칭 구조가 아닌 **대칭형(symmetric) 아키텍처**
- 위 아래, 좌 우가 아닌 **애플리케이션의 내부와 외부 세계**라는 대칭 구조를 가진다.
- 아키텍처의 대칭성을 가진 구조를 **그리기 쉬운** 대표적인 도형인 **육각형(hexagonal)**으로 설명
- 육각형, 6개의 면을 가졌다는 게 특별한 의미를 가지는 건 아니다.

# 헥사곤의 내부
- 쉽게 변하지 않는 **중요한 도메인 로직**을 담은 **코어 애플리케이션**
  - 도메인 로직을 가진 **트랜잭션 스크립트**
  - 애플리케이션 서비스와 **도메인 모델 패턴**을 따라서 만든 도메인

# 헥사곤의 외부
- **헥사곤과 상호작용(interaction)** 하는 모든 것 - **액터(Actor)**
- 사용자, 브라우저, CLI 명령, 기계, 다른 시스템
- 운영 환경, DB, 메시징 시스템, 메일 시스템, 원격 서비스
- 테스트

# 헥사고날 아키텍처의 특징과 혜택
- **테스팅! 운영 시스템에 연결되지 않고** 애플리케이션 테스트
- 애플리케이션과 상호작용하는 액터가 바뀌더라도 **다시 빌드하지 않고 테스트**
- UI 디테일이나 기술 정보가 **도메인 로직 안으로 노출되지 않도록** 보호한다. <br/>
  반대도 마찬가지
- 컴포넌트를 각각 개발하고 연결하는 방식으로 **큰 시스템을 분리**할 수 있다.
- 시간이 지나면서 **외부 연결을 다른 것으로 변경**할 수 있다.
- 기술 요소를 제거했기 때문에 **도메인 설계에 집중**할 수 있다.

# 헥사곤을 부르는 여러가지 이름
- 헥사곤
- **애플리케이션**
- 앱App
- 코어 시스템
- SuD(System under Development) 
- SuT(System under Test)

# 포트(port)
- 애플리케이션이 외부 세계와 **의도(intention)를 가지고 상호작용 하는** 아이디어를 캡처한 것
- 단순히 데이터를 주고받는 것이 아니라, **명확한 목적과 방향**을 가지고 **외부와 연결**된다.
- 애플리케이션이 정의한 **인터페이스**로 만들어진다.

# 인터페이스
- **Lollipop**: Provided Interface (기능 제공 인터페이스)
- **Socket**: Required Interface (기능 요구 인터페이스)

# 어댑터(Adapter)
- 애플리케이션의 포트를 액터가 직접 연결할 수 없다면 **인터페이스의 변환**을 위한 **어댑터**를 도입
- 브라우저를 통해서 애플리케이션의 회원 가입 포트의 기능 제공 인터페이스를 사용하려면? <br/>
  - 회원 가입 *&기능 제공 인터페이스**를 사용하는 **웹 컨트롤러 어댑터**를 만든다.
- 애플리케이션이 가진 회원 정보 저장 포트의 기능 요구 인터페이스로 DB와 직접 연결할 수 없다면?
  - **기능 요구 인터페이스**를 구현한 **리포지토리 어댑터**를 만든다.

# 포트와 어댑터 아키텍처
- 헥사고날 아키텍처의 특징을 담은 새로운 이름
- 하지만 여전히 헥사고날 아키텍처라는 이름이 더 많이 사용된다.

# 헥사고날 아키텍처의 비대칭성
- 애플리케이션이 제공하는 기능을 사용하는 액터와 이를 위한 어탭터
  - primary actor, primary adapter
  - driving actor, driving adapter
- 애플리케이션이 동작하는데 필요한 기능을 제공하는 액터와 이를 위한 어댑터
  - secondary actor, secondary adapter
  - driven actor, driven adapter

# 오해: 애플리케이션 내부에 도메인 계층을 만들어야 한다.
- 헥사고날 아키텍처는 애플리케이션 **내부 구현에 대한 원칙이나 요구사항이 없다**.
  - 스파게티 코드로 만들어도 된다.
  - 트랜잭션 스크립트, 도메인 모델 패턴과 애플리케이션 서비스 등도 가능하다.
  - 도메인 계층을 포함하는 아키텍처는 클린 아키텍처이다.
- 헥사고날 아키텍처는 클린 아키텍처, 어니언onion 아키텍처가 아니다.

# 오해: 헥사고날 아키텍처 패키지 구조를 따라야 한다.
- 헥사고날 아키텍처가 **요구하는 패키지 구조는 없다**.
- **애플리케이션과 어댑터 패키지를 분리**하는 것은 바람직하다. 
- **포트를 구분된 패키지에** 두는 것을 권장한다.

# 오해: 포트는 UseCase라는 접미사를 사용한다.
- **포트의 의도**를 담은 이름을 사용하면 된다.
- For+~ing 스타일의 권장 네이밍이 있지만 이를 따를 필요는 없다.

# 오해: 애플리케이션에는 도메인 모델만 넣고 JPA 엔티티 등은 어댑터에 둬야 한다.
- 애플리케이션 코드와 포트 인터페이스가 **외부 기술에 의존하지 않으면** 된다.

# 사실: 헥사고날 아키텍처가 요구하는 것
- 애플리케이션은 모든 외부와의 상호작용을 위해서 <br/>
  **provided interface와 required interface**를 정의한다.
- 애플리케이션과 상호작용 하는 **액터는 런타임에 구성**되어야 한다.
- 애플리케이션은 **액터에 대한 코드 의존성**을 가지면 안 된다.
- 액터는 **정의된 포트를 통해서만** 연결해야 한다.
- 포트의 인터페이스에는 **기술 의존성을 가지지 않는다**.

# Splearn 개발에 적용할 아키텍처 패턴
- 헥사고날 아키텍처
- 도메인 모델 패턴

# 헥사고날과 도메인 모델 패턴을 적용한 대칭형 계층 구조
- 외부에서 내부로 향하는 일종의 **계층 구조**
- **코드의 의존 방향**은 내부로만 향한다. <br/>
  어댑터 -> 애플리케이션 -> 도메인
- 단, 사용의 흐름은 비대칭적이다

# 도메인 주도 개발DDD의 아키텍처는?
- 4개의 계층형 아키텍처: Eric Evans
- 헥사고날 아키텍처: Vaugn Vernon

# 엔티티 식별자
- **고유성**: 두 개의 엔티티가 같은 값을 가지면 안 된다.
- **불변성**: 한 번 값이 할당되면 엔티티의 생명주기 동안 절대 변경되면 안 된다. 
  - 참조 정합성을 훼손하고, 연관관계를 깨뜨린다.
- 비즈니스적인 의미로부터 디커플링 되는 것이 낫다.
  - 자연 키 대신 **인조 키(대리 키) 사용**
