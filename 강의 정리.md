# 소프트웨어 개발에서 도메인
**사용자**가 **프로그램, 또는 소프트웨어 서비스를 적용하는 주제 영역을 도메인**이라 한다.

# 도메인 모델
- 소프트웨어는 도메인의 **핵심 개념과 요소들을 통합하고, 그 관계를 정확하게 구현**해야 한다.
- 도메인은 현실 세계의 일부이고, 단순히 코드로 직접 옮길수 없다 <br/>
  따라서, **도메인의 추상화인 도메인 모델**을 만들어야 한다.
- 도메인 모델은 소프트웨어가 해결하려는 특정 문제 영역(도메인)의 핵심지도
- 도메인에 존재하는 **중요한 개념과 이들 사이의 관계, 그리고 규칙**을 표현

# 도메인 주도 설계(Domain-Driven Design)
- 도메인의 **복잡성이 주는 문제를 해결**하기 위한 접근 방법
- **도메인 모델을 개발 과정의 중심**에 두는 방법이다.
- **도메인 모델이 설계와 코드까지** 이어져야 한다.
- 팀 안에서 **도메인 모델에 기반한 단일 어휘체계**를 만들고 <br/>
  이를 문서, 회의, 대화, 코드까지 일관되게 사용한다. (보편 언어)

# 도메인 모델과 보편 언어를 프로젝트에 기록
- 용어사전.md
- 도메인 모델.md
- 도메인 모델.drawio

# 도메인 모델 만들기
- 듣고 배우기
- '중요한 것'들 찾기 (개념 식별)
- '연결 고리' 찾기 (관계 정의)
- '것'들을 설명하기 (속성 및 기본 행위 명시)
- 그려보기 (시각화) <br/>
  예시) 클래스 다이어그램
- 이야기 하고 다듬기 (반복)

# 도메인 전문가가 없다면
- 기획자, PO를 가상의 도메인 전문가로 활용
- 다양한 탐색과 집단적인 학습 - 이벤트 스토밍
- 가설 기반의 점진적인 모델링
- 보편 언어의 의식적인 구축과 진화
- **경쟁 업체 서비스 분석**

# 엔티티(Entity)
- 도메인 안에 있는 대상이나 개념
- 고유한 식별자(identity)를 가지고 이를 통해서 개별적으로 구분된다.
- 생명주기(life cycle)를 가진다. 시간의 흐름에 따라 상태가 변경될 수 있다.

# 도메인 모델 패턴
- 도메인/비즈니스 로직을 구성하는 아키텍처 패턴의 한 가지
- 도메인 모델의 **속성과 행위를 모두 포함**하는 **도메인의 오브젝트 모델**이다.
- 오브젝트 모델이기 때문에 **복잡한 연관 관계, 커스텀 속성, 상속** 등을 사용할 수 있다.
- 트랜잭션 스크립트는 **하나의 업무절차(TX)를 처리하기 위한 스크립트**(메소드)를 만들고 <br/>
  비즈니스 로직을 **순서대로 코드로** 작성하는 방법

# 값 객체(Value Object)
- 도메인 모델에서 식별자가 필요하지 않고 속성/값으로만 구별되는 오브젝트
- 엔티티가 너무 많은 책임을 가지는 것을 방지하고 <br/>
  특정 속성 관련 행위를 분리해서 엔티티를 더 집중된 상태로 유지하게 한다.
- 원시 타입보다는 도메인 개념을 더 명시적으로 나타내서 모델의 명확성을 높인다.
- 생성 이후에 상태가 변하지 않고 변경이 필요하면 새로운 객체로 교체한다.
- 풍부한 기능을 가진다.
- 자체 유효성 검사도 가능하다.

# 원시 타입을 객체로 교체 - 리팩터링
- 원시 타입의 남용을 개선하고 코드 **명시성과 안정성을 높이는 리팩터팅** 방법
- 값 객체는 **도메인 모델**의 핵심 **구성 요소**로 **값 그 자체의 의미를 담아내고** <br/>
  **불변성, 동등성** 등의 도메인 로직을 포함하여 설계하는 방식

# 도메인 모델 패턴의 두 가지 스타일
- **단순 도메인 모델(Simple Domain Model)**: <br/>
  DB 설계와 유사, 테이블에 대해 하나의 도메인 오브젝트
- **풍성한 도메인 모델(Rich Domain Model)**: <br/>
  상속, 전략, GoF 디자인 패턴, 연관 관계 <br/>
  복잡한 로직에 적합하지만 DB 매핑이 어려울 수 있다.

# 도메인 로직의 API 개발
- 도메인 모델 패턴은 트랜잭션 스크립트처럼 **작업 단위의 절차형 API**를 만들기가 어렵다.
- 도메인 로직의 명확한 **작업 단위 API**를 제공하는 **애플리케이션 서비스**가 필요

# 아키텍처
- 시스템의 **기본적인 구조**를 정의한다.
- 시스템의 중요한 **품질 속성에 큰 영향**을 미친다.
- **설계 결정의 기반**이 되는 핵심적인 개념이다.
- 기본 **구성 요소**와 **상호 관계, 제약 조건, 원칙** 등을 포함한다.

# 계층형 아키텍처(Layered Architecture)
- 서브 시스템을 **계층(layers)으로 구조화** 하는 아키텍처 스타일이다.
- 계층은 **사용 관계로 연결**된다.
- 사용 관계는 일반적으로 **단방향이어야 한다**는 핵심 제약이 있다.
  - 상위 계층이 하위 계층의 서비스를 사용하는 **하향식 흐름**을 가진다.
- 각 계층이 하위 계층의 내부 작동 방식을 알지 못하고 **제한된 인터페이스만 사용**하도록 한다. <br/>
  (계층 격리 Layers of Isolation)
  - 어떤 레이어의 **변경**이 다른 레이어의 컴포넌트에게 가능한 **영향을 주지 않도록** 해야 한다.

# 헥사고날 아키텍처
- 2005년 **앨리스터 코번**이 제안한 아키텍처
- 계층형 아키텍처의 단방형 비대칭 구조가 아닌 **대칭형(symmetric) 아키텍처**
- 위 아래, 좌 우가 아닌 **애플리케이션의 내부와 외부 세계**라는 대칭 구조를 가진다.
- 아키텍처의 대칭성을 가진 구조를 **그리기 쉬운** 대표적인 도형인 **육각형(hexagonal)**으로 설명
- 육각형, 6개의 면을 가졌다는 게 특별한 의미를 가지는 건 아니다.

# 헥사곤의 내부
- 쉽게 변하지 않는 **중요한 도메인 로직**을 담은 **코어 애플리케이션**
  - 도메인 로직을 가진 **트랜잭션 스크립트**
  - 애플리케이션 서비스와 **도메인 모델 패턴**을 따라서 만든 도메인

# 헥사곤의 외부
- **헥사곤과 상호작용(interaction)** 하는 모든 것 - **액터(Actor)**
- 사용자, 브라우저, CLI 명령, 기계, 다른 시스템
- 운영 환경, DB, 메시징 시스템, 메일 시스템, 원격 서비스
- 테스트

# 헥사고날 아키텍처의 특징과 혜택
- **테스팅! 운영 시스템에 연결되지 않고** 애플리케이션 테스트
- 애플리케이션과 상호작용하는 액터가 바뀌더라도 **다시 빌드하지 않고 테스트**
- UI 디테일이나 기술 정보가 **도메인 로직 안으로 노출되지 않도록** 보호한다. <br/>
  반대도 마찬가지
- 컴포넌트를 각각 개발하고 연결하는 방식으로 **큰 시스템을 분리**할 수 있다.
- 시간이 지나면서 **외부 연결을 다른 것으로 변경**할 수 있다.
- 기술 요소를 제거했기 때문에 **도메인 설계에 집중**할 수 있다.

# 헥사곤을 부르는 여러가지 이름
- 헥사곤
- **애플리케이션**
- 앱App
- 코어 시스템
- SuD(System under Development) 
- SuT(System under Test)

# 포트(port)
- 애플리케이션이 외부 세계와 **의도(intention)를 가지고 상호작용 하는** 아이디어를 캡처한 것
- 단순히 데이터를 주고받는 것이 아니라, **명확한 목적과 방향**을 가지고 **외부와 연결**된다.
- 애플리케이션이 정의한 **인터페이스**로 만들어진다.

# 인터페이스
- **Lollipop**: Provided Interface (기능 제공 인터페이스)
- **Socket**: Required Interface (기능 요구 인터페이스)

# 어댑터(Adapter)
- 애플리케이션의 포트를 액터가 직접 연결할 수 없다면 **인터페이스의 변환**을 위한 **어댑터**를 도입
- 브라우저를 통해서 애플리케이션의 회원 가입 포트의 기능 제공 인터페이스를 사용하려면? <br/>
  - 회원 가입 *&기능 제공 인터페이스**를 사용하는 **웹 컨트롤러 어댑터**를 만든다.
- 애플리케이션이 가진 회원 정보 저장 포트의 기능 요구 인터페이스로 DB와 직접 연결할 수 없다면?
  - **기능 요구 인터페이스**를 구현한 **리포지토리 어댑터**를 만든다.

# 포트와 어댑터 아키텍처
- 헥사고날 아키텍처의 특징을 담은 새로운 이름
- 하지만 여전히 헥사고날 아키텍처라는 이름이 더 많이 사용된다.

# 헥사고날 아키텍처의 비대칭성
- 애플리케이션이 제공하는 기능을 사용하는 액터와 이를 위한 어탭터
  - primary actor, primary adapter
  - driving actor, driving adapter
- 애플리케이션이 동작하는데 필요한 기능을 제공하는 액터와 이를 위한 어댑터
  - secondary actor, secondary adapter
  - driven actor, driven adapter

# 오해: 애플리케이션 내부에 도메인 계층을 만들어야 한다.
- 헥사고날 아키텍처는 애플리케이션 **내부 구현에 대한 원칙이나 요구사항이 없다**.
  - 스파게티 코드로 만들어도 된다.
  - 트랜잭션 스크립트, 도메인 모델 패턴과 애플리케이션 서비스 등도 가능하다.
  - 도메인 계층을 포함하는 아키텍처는 클린 아키텍처이다.
- 헥사고날 아키텍처는 클린 아키텍처, 어니언onion 아키텍처가 아니다.

# 오해: 헥사고날 아키텍처 패키지 구조를 따라야 한다.
- 헥사고날 아키텍처가 **요구하는 패키지 구조는 없다**.
- **애플리케이션과 어댑터 패키지를 분리**하는 것은 바람직하다. 
- **포트를 구분된 패키지에** 두는 것을 권장한다.

# 오해: 포트는 UseCase라는 접미사를 사용한다.
- **포트의 의도**를 담은 이름을 사용하면 된다.
- For+~ing 스타일의 권장 네이밍이 있지만 이를 따를 필요는 없다.

# 오해: 애플리케이션에는 도메인 모델만 넣고 JPA 엔티티 등은 어댑터에 둬야 한다.
- 애플리케이션 코드와 포트 인터페이스가 **외부 기술에 의존하지 않으면** 된다.

# 사실: 헥사고날 아키텍처가 요구하는 것
- 애플리케이션은 모든 외부와의 상호작용을 위해서 <br/>
  **provided interface와 required interface**를 정의한다.
- 애플리케이션과 상호작용 하는 **액터는 런타임에 구성**되어야 한다.
- 애플리케이션은 **액터에 대한 코드 의존성**을 가지면 안 된다.
- 액터는 **정의된 포트를 통해서만** 연결해야 한다.
- 포트의 인터페이스에는 **기술 의존성을 가지지 않는다**.

# Splearn 개발에 적용할 아키텍처 패턴
- 헥사고날 아키텍처
- 도메인 모델 패턴

# 헥사고날과 도메인 모델 패턴을 적용한 대칭형 계층 구조
- 외부에서 내부로 향하는 일종의 **계층 구조**
- **코드의 의존 방향**은 내부로만 향한다. <br/>
  어댑터 -> 애플리케이션 -> 도메인
- 단, 사용의 흐름은 비대칭적이다

# 도메인 주도 개발DDD의 아키텍처는?
- 4개의 계층형 아키텍처: Eric Evans
- 헥사고날 아키텍처: Vaugn Vernon

# 엔티티 식별자
- **고유성**: 두 개의 엔티티가 같은 값을 가지면 안 된다.
- **불변성**: 한 번 값이 할당되면 엔티티의 생명주기 동안 절대 변경되면 안 된다. 
  - 참조 정합성을 훼손하고, 연관관계를 깨뜨린다.
- 비즈니스적인 의미로부터 디커플링 되는 것이 낫다.
  - 자연 키 대신 **인조 키(대리 키) 사용**

# JPA 모델과 도메인 모델은 다른 것인가?
- **도메인 모델**은 DB와 매핑되는 **데이터 모델**과 다르며 이를 **분리**해야 한다.
  - 어댑터 계층에 JPA 엔티티 등의 모델을 따로 만들고
  - Repository를 구현한 어댑터를 이용해서 도메인 오브젝트와 JPA 오브젝트를 매핑해준다.
  - Member외에 MemberEntity 클래스를 만들어 JPA 관련 설정은 모두 이곳으로 옮긴다.
  - MemberRepository를 구현한 MemberRepositoryJpaAdapter에서 이 두가지 오브젝트를 서로 매핑해주는 코드를 작성한다.

# 이런 접근 방법을 선호하는 이유
- 데이터 모델과 도메인 모델이 **너무 다른 경우** 
  - **레거시 DB**에 **도메인 모델 설계**를 적용하는 경우
- 복잡한 도메인 모델이 데이터 모델과 **간단히 매핑되지 않는** 경우
  - JPA 모델과는 다른 도메인 모델이 존재한다면
- 데이터 **저장 기술이 바뀌는** 경우
  - Spring Data 프로젝트 존재 이유
- 코드에 등장하는 JPA 애노테이션은 **기술 의존적**이니까
  - 애노테이션이 코드의 실행에 영향을 줄까? 
- 도메인 코드에 **관심사가 다른** JPA 매핑 애노테이션, DB 정보가 들어가니까
  - 가독성 또는 취향

# JPA 기술의 정체성
- ORM: 패러다임이 다른 **관계형 DB와 객체지향 모델**의 **불일치를 해결**하는 기술
  - SQL 매핑과는 다르다.
- JPA의 기술적 목표는 자바 애플리케이션 개발자가 관계형 데이터베이스를 관리하기 위해 <br/>
  **자바 도메인 모델**을 활용할 수 있는 객체/관계 매핑 기능을 제공하는 것
- JPA의 엔티티는 **경량 영속 도메인 오브젝트**

# 도메인 모델 패턴
- 단순 도메인 모델은 테이블과 클래스가 1:1로 매핑된다.
- 복잡한 도메인 모델은 **DB 매핑이 어렵다**는 문제가 있다.
  - 이걸 해결해주는 것이 JPA(ORM) 기술
- JPA(ORM)이 매핑을 통해서 해결하려는 **패러다임 불일치 문제**
  1. 세분성(Granularity) 불일치
  2. 상속(Subtype) 불일치
  3. 정체성(Identity) 불일치
  4. 연관(Association) 불일치
  5. 데이터 탐색(Navigation) 불일치

# 스프링 데이터 프로젝트
- **다양한 데이터 저장소**(관계형 또는 비관계형 DB, 클라우드 기반 데이터 서비스)에 대한 <br/>
  데이터 접근을 **단순하고 일관된 프로그래밍 모델**로 제공
  - 일관된 프로그래밍 모델: 저장소의 종류와 관계없이 동일한 방식으로 데이터에 접근하도록 한다.
  - 보일러 플레이트 코드 감소
  - 데이터 저장소의 특성 유지
  - 확장성과 유연성
- Repository<**T**, ID>
  - T: **도메인 타입 = 엔티티 = 애그리거트 루트**

# 도메인 모델과 JPA 모델을 반드시 분리해야 한다는 주장에 대한 반박
- 대부분 데이터 모델과 도메인 모델이 **다르지 않음**
- 복잡한 도메인 모델의 매핑은 **JPA가 충분히 지원**
- 모델 변환 로직과 유사한 두 가지 클래스로 인한 **불필요한 복잡성 증가**
- JPA는 근본적으로 **도메인 오브젝트의 매핑**을 위해서 설계된 기술
- JPA는 도메인 계층을 **침범하지 않음**
- 복잡한 쿼리 로직은 **커스톰 리포지토리**와 **어댑터 구현**을 통해서 개발 가능
- 도메인 계층과 데이터 계층의 결합은 불가피하다.
  - 이 둘이 완적히 독립적인 경우는 매우 드물다.
- JPA는 충분히 **유연하고 막강하며**, Spring Data JPA는 **놀라운 수준의 도메인 중심 개발** 지원

# 애그리거트(Aggregate)
- 도메인 주도 개발DDD에 소개된 **도메인 모델 구성 요소/패턴**의 하나이다.
- **데이터 변경의 목적**을 위해 **하나의 단위로 취급**되는 **연관된 객체들의 클러스터**이다.
- **루트(root)** 와 **경계(boundary)** 를 가진다.
- 경계 내부에는 **엔티티와 값 객체**가 하나 또는 여러 개가 존재할 수 있다.
- 애그리거트 루트는 내부에 포함된 **단일 엔티티**이다.

# 애그리거트의 특징
- 데이터 변경 시 **하나의 단위**로 취급: 데이터 변경의 일관성을 유지한다.
- 루트를 통한 접근 제어: 외부 객체는 **루트 엔티티에만 참조**를 가질 수 있다.
- **데이터 일관성** 유지:
  - 경계 내의 어떤 변경 사항이 있을 때 전체 애그리그트의 모든 **불변식이 충족**되어야 한다. 
  - 애그리거트를 넘어서는 불변식은 **이벤트나 배치** 등을 통해 특정 시간 내에 해결할 수 있다.
- 검색 및 접근 방식: **리포지토리**를 통해서 **애그리거트 루트만** 직접 얻을 수 있다.
  - 내부 엔티티는 루트로부터 연관관계를 통해서 접근한다.
- 생명주기 관리 캡슐화: **Factory**와 **Repository**를 이용해서 객체들을 생명주기에 걸쳐 체계적이고 의미있는 단위로 조작

# 애그리거트의 목표
- 일관성 유지: 객체 그룹에 적용되는 **불변식을 유지**하는 수단
- 이해 용이성: 객체의 시작과 끝을 명확히 해서 **모델을 더 쉽게 이해**하게 한다.
- 트랜잭션 및 동시성 관리: **트랜잭션 범위**와 **데이터 일관성** 유지 방법 제공
- 모델 단순화: 연관 관계 탐색을 제한하고 **루트를 통해서만 접근**하도록 해준다.
- Factory와 Repository가 **복잡한 생명주기** 전환을 캡슐화하는 단위가 되도록 한다.

# 애그리거트 적용 방법
- JPA의 **cascading**을 적절하게 활용한다.
- **리포지토리**는 **애그리거트 단위**로 만든다.
  - 스프링 데이터 JPA의 핵심 원칙
  - Repository<T, ID>: T = Aggregate Root
  - 리포지토리 리턴 타입은 애그리거트 루트
- 가능하다면 하나의 트랜잭션에 하나의 애그리거트만 변경한다.
- 다른 애그리거트의 **참조는 애그리거트 루트**에 대해서만 한다. 
  - 연관관계 애그리거트 루트의 레퍼런스 대신 루트의 ID 값만 저장하기도 한다.

# 애그리거트 설계와 적용의 어려움
- 적절한 애그리거트 경계를 선택하는 것은 꽤 어려운 결정이다.
- 개발하면서 애그리거트의 범위가 달라지기도 한다.
  - 대체로 **작은 애그리거트**가 될 가능성이 높다.
- 성능에 부담을 주게 된다. (lazy loading)의 도움이 필요
- 내부 엔티티로의 직접 접근이나 여러 애그리거트를 한번에 조회하는 기능이 필요한 경우가 있다.
- **도메인 이벤트**와 **최종적 일관성(eventual consistency)** 의 사용이 요구된다. 
- 완벽한 애그리거트가 아니어도 괜찮다.
  - 우리는 DDD 하지 않는다고 하면 된다.

# 헥사고날 아키텍처와 애그리거트
- **애그리거트 단위로 애플리케이션(헥사곤)을 구성**하는 방법이 유용하다.
- 다른 애그리거트로의 접근은 애플리케이션 **포트를 통해서 ID를 전달**하는 방식으로
  - 애플리케이션 내부 리포지토리에서 루트 엔티티를 조회하는 방식으로 이루어지게 강제할 수 있다.
- **도메인 이벤트와 리스너**를 이용해서 애그리거트 사이의 작업을 연결할 수도 있다.
  - 이벤트에 필요한 애그리거트 루트 ID를 전달한다.
- 애그리거트를 설계하고 각각을 독립적인 애플리케이션으로 분리하자
